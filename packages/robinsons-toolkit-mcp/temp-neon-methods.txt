  private async listProjects(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append('limit', args.limit.toString());
    if (args.search) params.append('search', args.search);
    if (args.cursor) params.append('cursor', args.cursor);
    if (args.org_id) params.append('org_id', args.org_id);

    const response = await this.client.get(`/projects?${params.toString()}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async listOrganizations(args: any) {
    const response = await this.client.get('/users/me/organizations');
    let orgs = response.data.organizations || [];

    if (args.search) {
      const searchLower = args.search.toLowerCase();
      orgs = orgs.filter((org: any) =>
        org.name?.toLowerCase().includes(searchLower) ||
        org.id?.toLowerCase().includes(searchLower)
      );
    }

    return { content: [{ type: 'text', text: JSON.stringify({ organizations: orgs }, null, 2) }] };
  }

  private async listSharedProjects(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append('limit', args.limit.toString());
    if (args.search) params.append('search', args.search);
    if (args.cursor) params.append('cursor', args.cursor);

    const response = await this.client.get(`/projects/shared?${params.toString()}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async createProject(args: any) {
    const body: any = {};
    if (args.name) body.project = { name: args.name };
    if (args.org_id) body.project = { ...body.project, org_id: args.org_id };
    if (args.region_id) body.project = { ...body.project, region_id: args.region_id };
    if (args.pg_version) body.project = { ...body.project, pg_version: args.pg_version };

    const response = await this.client.post('/projects', body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async deleteProject(args: any) {
    const response = await this.client.delete(`/projects/${args.projectId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async describeProject(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async updateProject(args: any) {
    const body: any = { project: {} };
    if (args.name) body.project.name = args.name;
    if (args.settings) body.project.settings = args.settings;

    const response = await this.client.patch(`/projects/${args.projectId}`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async getProjectOperations(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append('limit', args.limit.toString());

    const response = await this.client.get(`/projects/${args.projectId}/operations?${params.toString()}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async getProjectConsumption(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append('from', args.from);
    if (args.to) params.append('to', args.to);

    const response = await this.client.get(`/projects/${args.projectId}/consumption?${params.toString()}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async setProjectSettings(args: any) {
    const response = await this.client.patch(`/projects/${args.projectId}`, { project: { settings: args.settings } });
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async getProjectQuotas(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}`);
    const quotas = response.data.project?.quotas || {};
    return { content: [{ type: 'text', text: JSON.stringify(quotas, null, 2) }] };
  }

  private async cloneProject(args: any) {
    return { content: [{ type: 'text', text: 'Project cloning: Create new project and copy branches using create_project and create_branch tools.' }] };
  }

  private async getProjectPermissions(args: any) {
    return { content: [{ type: 'text', text: 'Project permissions: Use organization API to manage project access.' }] };
  }

  private async createBranch(args: any) {
    const body: any = { branch: {} };
    if (args.branchName) body.branch.name = args.branchName;
    if (args.parent_id) body.branch.parent_id = args.parent_id;

    const response = await this.client.post(`/projects/${args.projectId}/branches`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async deleteBranch(args: any) {
    const response = await this.client.delete(`/projects/${args.projectId}/branches/${args.branchId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async describeBranch(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/branches/${args.branchId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async resetFromParent(args: any) {
    const body: any = {};
    if (args.preserveUnderName) body.preserve_under_name = args.preserveUnderName;

    const response = await this.client.post(`/projects/${args.projectId}/branches/${args.branchIdOrName}/reset`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async updateBranch(args: any) {
    const body: any = { branch: {} };
    if (args.name) body.branch.name = args.name;
    if (args.protected !== undefined) body.branch.protected = args.protected;

    const response = await this.client.patch(`/projects/${args.projectId}/branches/${args.branchId}`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async listBranches(args: any) {
    const params = new URLSearchParams();
    if (args.search) params.append('search', args.search);

    const response = await this.client.get(`/projects/${args.projectId}/branches?${params.toString()}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async getBranchDetails(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/branches/${args.branchId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async restoreBranch(args: any) {
    return { content: [{ type: 'text', text: 'Branch restore: Use create_branch with parent_timestamp to restore to specific point in time.' }] };
  }

  private async setBranchProtection(args: any) {
    const response = await this.client.patch(`/projects/${args.projectId}/branches/${args.branchId}`, {
      branch: { protected: args.protected }
    });
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async getBranchSchemaDiff(args: any) {
    return { content: [{ type: 'text', text: 'Schema diff: Use run_sql to query information_schema on both branches and compare.' }] };
  }

  private async getBranchDataDiff(args: any) {
    return { content: [{ type: 'text', text: 'Data diff: Use run_sql to query and compare data between branches.' }] };
  }

  private async mergeBranches(args: any) {
    return { content: [{ type: 'text', text: 'Branch merge: Use prepare_database_migration to apply changes from source to target branch.' }] };
  }

  private async promoteBranch(args: any) {
    const response = await this.client.post(`/projects/${args.projectId}/branches/${args.branchId}/set_as_primary`, {});
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async setBranchRetention(args: any) {
    return { content: [{ type: 'text', text: 'Branch retention: Configure via project settings.' }] };
  }

  private async getBranchHistory(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/branches/${args.branchId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async restoreBranchToTimestamp(args: any) {
    const body = { timestamp: args.timestamp };
    const response = await this.client.post(`/projects/${args.projectId}/branches/${args.branchId}/restore`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async getBranchSize(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/branches/${args.branchId}`);
    const size = response.data.branch?.logical_size || 0;
    return { content: [{ type: 'text', text: `Branch size: ${size} bytes` }] };
  }

  private async setBranchComputeSettings(args: any) {
    return { content: [{ type: 'text', text: 'Compute settings: Use update_endpoint to configure compute for branch endpoints.' }] };
  }

  private async getBranchConnections(args: any) {
    return { content: [{ type: 'text', text: 'Active connections: Use run_sql with "SELECT * FROM pg_stat_activity" to view connections.' }] };
  }

  private async listBranchComputes(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/endpoints`);
    const branchEndpoints = args.branchId
      ? response.data.endpoints?.filter((e: any) => e.branch_id === args.branchId)
      : response.data.endpoints;
    return { content: [{ type: 'text', text: JSON.stringify(branchEndpoints, null, 2) }] };
  }

  private async runSql(args: any) { return { content: [{ type: 'text', text: 'SQL execution: Not yet implemented' }] }; }
  private async runSqlTransaction(args: any) { return { content: [{ type: 'text', text: 'SQL transaction: Not yet implemented' }] }; }
  private async getConnectionString(args: any) { return { content: [{ type: 'text', text: 'Connection string: Not yet implemented' }] }; }
  private async getDatabaseTables(args: any) { return { content: [{ type: 'text', text: 'Database tables: Not yet implemented' }] }; }
  private async describeTableSchema(args: any) { return { content: [{ type: 'text', text: 'Table schema: Not yet implemented' }] }; }
  private async explainSqlStatement(args: any) { return { content: [{ type: 'text', text: 'Explain SQL: Not yet implemented' }] }; }
  private async listSlowQueries(args: any) { return { content: [{ type: 'text', text: 'Slow queries: Not yet implemented' }] }; }
  private async optimizeQuery(args: any) { return { content: [{ type: 'text', text: 'Query optimization: Not yet implemented' }] }; }
  private async suggestIndexes(args: any) { return { content: [{ type: 'text', text: 'Index suggestions: Not yet implemented' }] }; }
  private async analyzeQueryPlan(args: any) { return { content: [{ type: 'text', text: 'Query plan analysis: Not yet implemented' }] }; }
  private async createDatabase(args: any) { return { content: [{ type: 'text', text: 'Create database: Not yet implemented' }] }; }
  private async deleteDatabase(args: any) { return { content: [{ type: 'text', text: 'Delete database: Not yet implemented' }] }; }
  private async listDatabases(args: any) { return { content: [{ type: 'text', text: 'List databases: Not yet implemented' }] }; }
  private async getDatabaseSize(args: any) { return { content: [{ type: 'text', text: 'Database size: Not yet implemented' }] }; }
  private async getDatabaseStats(args: any) { return { content: [{ type: 'text', text: 'Database stats: Not yet implemented' }] }; }
  private async vacuumDatabase(args: any) { return { content: [{ type: 'text', text: 'Vacuum database: Not yet implemented' }] }; }
  private async analyzeDatabase(args: any) { return { content: [{ type: 'text', text: 'Analyze database: Not yet implemented' }] }; }
  private async reindexDatabase(args: any) { return { content: [{ type: 'text', text: 'Reindex database: Not yet implemented' }] }; }
  private async getDatabaseLocks(args: any) { return { content: [{ type: 'text', text: 'Database locks: Not yet implemented' }] }; }
  private async killDatabaseQuery(args: any) { return { content: [{ type: 'text', text: 'Kill query: Not yet implemented' }] }; }
  private async getDatabaseActivity(args: any) { return { content: [{ type: 'text', text: 'Database activity: Not yet implemented' }] }; }
  private async backupDatabase(args: any) { return { content: [{ type: 'text', text: 'Backup database: Not yet implemented' }] }; }
  private async prepareDatabaseMigration(args: any) { return { content: [{ type: 'text', text: 'Prepare migration: Not yet implemented' }] }; }
  private async completeDatabaseMigration(args: any) { return { content: [{ type: 'text', text: 'Complete migration: Not yet implemented' }] }; }
  private async prepareQueryTuning(args: any) { return { content: [{ type: 'text', text: 'Prepare query tuning: Not yet implemented' }] }; }
  private async completeQueryTuning(args: any) { return { content: [{ type: 'text', text: 'Complete query tuning: Not yet implemented' }] }; }
  private async createRole(args: any) { return { content: [{ type: 'text', text: 'Create role: Not yet implemented' }] }; }
  private async deleteRole(args: any) { return { content: [{ type: 'text', text: 'Delete role: Not yet implemented' }] }; }
  private async listRoles(args: any) { return { content: [{ type: 'text', text: 'List roles: Not yet implemented' }] }; }
  private async updateRole(args: any) { return { content: [{ type: 'text', text: 'Update role: Not yet implemented' }] }; }
  private async grantRolePermissions(args: any) { return { content: [{ type: 'text', text: 'Grant permissions: Not yet implemented' }] }; }
  private async revokeRolePermissions(args: any) { return { content: [{ type: 'text', text: 'Revoke permissions: Not yet implemented' }] }; }
  private async getRolePermissions(args: any) { return { content: [{ type: 'text', text: 'Get permissions: Not yet implemented' }] }; }
  private async resetRolePassword(args: any) { return { content: [{ type: 'text', text: 'Reset password: Not yet implemented' }] }; }
  private async createEndpoint(args: any) { return { content: [{ type: 'text', text: 'Create endpoint: Not yet implemented' }] }; }
  private async deleteEndpoint(args: any) { return { content: [{ type: 'text', text: 'Delete endpoint: Not yet implemented' }] }; }
  private async updateEndpoint(args: any) { return { content: [{ type: 'text', text: 'Update endpoint: Not yet implemented' }] }; }
  private async startEndpoint(args: any) { return { content: [{ type: 'text', text: 'Start endpoint: Not yet implemented' }] }; }
  private async suspendEndpoint(args: any) { return { content: [{ type: 'text', text: 'Suspend endpoint: Not yet implemented' }] }; }
  private async restartEndpoint(args: any) { return { content: [{ type: 'text', text: 'Restart endpoint: Not yet implemented' }] }; }
  private async getEndpointMetrics(args: any) { return { content: [{ type: 'text', text: 'Endpoint metrics: Not yet implemented' }] }; }
  private async setEndpointAutoscaling(args: any) { return { content: [{ type: 'text', text: 'Set autoscaling: Not yet implemented' }] }; }
  private async getEndpointLogs(args: any) { return { content: [{ type: 'text', text: 'Endpoint logs: Not yet implemented' }] }; }
  private async setEndpointPooling(args: any) { return { content: [{ type: 'text', text: 'Set pooling: Not yet implemented' }] }; }
  private async getQueryStatistics(args: any) { return { content: [{ type: 'text', text: 'Query statistics: Not yet implemented' }] }; }
  private async getSlowQueryLog(args: any) { return { content: [{ type: 'text', text: 'Slow query log: Not yet implemented' }] }; }
  private async getConnectionStats(args: any) { return { content: [{ type: 'text', text: 'Connection stats: Not yet implemented' }] }; }
  private async getStorageMetrics(args: any) { return { content: [{ type: 'text', text: 'Storage metrics: Not yet implemented' }] }; }
  private async getComputeMetrics(args: any) { return { content: [{ type: 'text', text: 'Compute metrics: Not yet implemented' }] }; }
  private async getIoMetrics(args: any) { return { content: [{ type: 'text', text: 'I/O metrics: Not yet implemented' }] }; }
  private async getCacheHitRatio(args: any) { return { content: [{ type: 'text', text: 'Cache hit ratio: Not yet implemented' }] }; }
  private async getIndexUsage(args: any) { return { content: [{ type: 'text', text: 'Index usage: Not yet implemented' }] }; }
  private async getTableBloat(args: any) { return { content: [{ type: 'text', text: 'Table bloat: Not yet implemented' }] }; }
  private async getReplicationLag(args: any) { return { content: [{ type: 'text', text: 'Replication lag: Not yet implemented' }] }; }
  private async getCheckpointStats(args: any) { return { content: [{ type: 'text', text: 'Checkpoint stats: Not yet implemented' }] }; }
  private async getWalStats(args: any) { return { content: [{ type: 'text', text: 'WAL stats: Not yet implemented' }] }; }
  private async setMonitoringAlerts(args: any) { return { content: [{ type: 'text', text: 'Set alerts: Not yet implemented' }] }; }
  private async getAlertHistory(args: any) { return { content: [{ type: 'text', text: 'Alert history: Not yet implemented' }] }; }
  private async getPerformanceInsights(args: any) { return { content: [{ type: 'text', text: 'Performance insights: Not yet implemented' }] }; }
  private async listBackups(args: any) { return { content: [{ type: 'text', text: 'List backups: Not yet implemented' }] }; }
  private async createBackup(args: any) { return { content: [{ type: 'text', text: 'Create backup: Not yet implemented' }] }; }
  private async restoreBackup(args: any) { return { content: [{ type: 'text', text: 'Restore backup: Not yet implemented' }] }; }
  private async deleteBackup(args: any) { return { content: [{ type: 'text', text: 'Delete backup: Not yet implemented' }] }; }
  private async getBackupStatus(args: any) { return { content: [{ type: 'text', text: 'Backup status: Not yet implemented' }] }; }
  private async scheduleBackup(args: any) { return { content: [{ type: 'text', text: 'Schedule backup: Not yet implemented' }] }; }
  private async exportBackup(args: any) { return { content: [{ type: 'text', text: 'Export backup: Not yet implemented' }] }; }
  private async validateBackup(args: any) { return { content: [{ type: 'text', text: 'Validate backup: Not yet implemented' }] }; }
  private async enableIpAllowlist(args: any) { return { content: [{ type: 'text', text: 'Enable IP allowlist: Not yet implemented' }] }; }
  private async getIpAllowlist(args: any) { return { content: [{ type: 'text', text: 'Get IP allowlist: Not yet implemented' }] }; }
  private async enableSslEnforcement(args: any) { return { content: [{ type: 'text', text: 'Enable SSL: Not yet implemented' }] }; }
  private async rotateCredentials(args: any) { return { content: [{ type: 'text', text: 'Rotate credentials: Not yet implemented' }] }; }
  private async getAuditLog(args: any) { return { content: [{ type: 'text', text: 'Audit log: Not yet implemented' }] }; }
  private async enableEncryption(args: any) { return { content: [{ type: 'text', text: 'Enable encryption: Not yet implemented' }] }; }
  private async getSecurityScan(args: any) { return { content: [{ type: 'text', text: 'Security scan: Not yet implemented' }] }; }
  private async setPasswordPolicy(args: any) { return { content: [{ type: 'text', text: 'Set password policy: Not yet implemented' }] }; }
  private async enable2fa(args: any) { return { content: [{ type: 'text', text: 'Enable 2FA: Not yet implemented' }] }; }
  private async getComplianceReport(args: any) { return { content: [{ type: 'text', text: 'Compliance report: Not yet implemented' }] }; }
  private async getCostBreakdown(args: any) { return { content: [{ type: 'text', text: 'Cost breakdown: Not yet implemented' }] }; }
  private async getCostForecast(args: any) { return { content: [{ type: 'text', text: 'Cost forecast: Not yet implemented' }] }; }
  private async setCostAlerts(args: any) { return { content: [{ type: 'text', text: 'Set cost alerts: Not yet implemented' }] }; }
  private async getCostOptimizationTips(args: any) { return { content: [{ type: 'text', text: 'Cost optimization: Not yet implemented' }] }; }
  private async getBillingHistory(args: any) { return { content: [{ type: 'text', text: 'Billing history: Not yet implemented' }] }; }
  private async exportCostReport(args: any) { return { content: [{ type: 'text', text: 'Export cost report: Not yet implemented' }] }; }
  private async setBudgetLimits(args: any) { return { content: [{ type: 'text', text: 'Set budget limits: Not yet implemented' }] }; }
  private async getResourceRecommendations(args: any) { return { content: [{ type: 'text', text: 'Resource recommendations: Not yet implemented' }] }; }
  private async createWebhook(args: any) { return { content: [{ type: 'text', text: 'Create webhook: Not yet implemented' }] }; }
  private async listWebhooks(args: any) { return { content: [{ type: 'text', text: 'List webhooks: Not yet implemented' }] }; }
  private async deleteWebhook(args: any) { return { content: [{ type: 'text', text: 'Delete webhook: Not yet implemented' }] }; }
  private async testWebhook(args: any) { return { content: [{ type: 'text', text: 'Test webhook: Not yet implemented' }] }; }
  private async getWebhookLogs(args: any) { return { content: [{ type: 'text', text: 'Webhook logs: Not yet implemented' }] }; }
  private async createApiKey(args: any) { return { content: [{ type: 'text', text: 'Create API key: Not yet implemented' }] }; }
  private async detectNPlusOne(args: any) { return { content: [{ type: 'text', text: 'Detect N+1: Not yet implemented' }] }; }
  private async suggestPartitioning(args: any) { return { content: [{ type: 'text', text: 'Suggest partitioning: Not yet implemented' }] }; }
  private async analyzeTableStatistics(args: any) { return { content: [{ type: 'text', text: 'Table statistics: Not yet implemented' }] }; }
  private async suggestVacuumStrategy(args: any) { return { content: [{ type: 'text', text: 'Vacuum strategy: Not yet implemented' }] }; }
  private async detectMissingIndexes(args: any) { return { content: [{ type: 'text', text: 'Missing indexes: Not yet implemented' }] }; }
  private async analyzeJoinPerformance(args: any) { return { content: [{ type: 'text', text: 'Join performance: Not yet implemented' }] }; }
  private async suggestMaterializedViews(args: any) { return { content: [{ type: 'text', text: 'Materialized views: Not yet implemented' }] }; }
  private async getTableDependencies(args: any) { return { content: [{ type: 'text', text: 'Table dependencies: Not yet implemented' }] }; }
  private async suggestQueryRewrite(args: any) { return { content: [{ type: 'text', text: 'Query rewrite: Not yet implemented' }] }; }
  private async analyzeDeadlocks(args: any) { return { content: [{ type: 'text', text: 'Analyze deadlocks: Not yet implemented' }] }; }
  private async provisionNeonAuth(args: any) { return { content: [{ type: 'text', text: 'Provision Neon Auth: Not yet implemented' }] }; }

  // API KEY MANAGEMENT
  private async listApiKeys(args: any) {
    const response = await this.client.get('/api_keys');
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async createApiKeyForProject(args: any) {
    const body: any = { key_name: args.keyName };
    if (args.projectId) body.project_id = args.projectId;

    const response = await this.client.post('/api_keys', body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async revokeApiKey(args: any) {
    const response = await this.client.delete(`/api_keys/${args.keyId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async getConnectionPoolerConfig(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/endpoints/${args.endpointId}`);
    const poolerConfig = response.data.endpoint?.pooler_enabled ? {
      pooler_enabled: response.data.endpoint.pooler_enabled,
      pooler_mode: response.data.endpoint.pooler_mode,
      settings: response.data.endpoint.settings
    } : { pooler_enabled: false };

    return { content: [{ type: 'text', text: JSON.stringify(poolerConfig, null, 2) }] };
  }

  private async updateConnectionPoolerConfig(args: any) {
    const body: any = { endpoint: {} };
    if (args.poolMode) body.endpoint.pooler_mode = args.poolMode;
    if (args.poolSize !== undefined) body.endpoint.settings = { ...body.endpoint.settings, pool_size: args.poolSize };
    if (args.maxClientConn !== undefined) body.endpoint.settings = { ...body.endpoint.settings, max_client_conn: args.maxClientConn };

    const response = await this.client.patch(`/projects/${args.projectId}/endpoints/${args.endpointId}`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async createReadReplica(args: any) {
    const body: any = {
      endpoint: {
        branch_id: args.branchId,
        type: 'read_only'
      }
    };
    if (args.region) body.endpoint.region_id = args.region;

    const response = await this.client.post(`/projects/${args.projectId}/endpoints`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async listReadReplicas(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/endpoints`);
    const readReplicas = response.data.endpoints?.filter((ep: any) =>
      ep.type === 'read_only' && ep.branch_id === args.branchId
    ) || [];

    return { content: [{ type: 'text', text: JSON.stringify({ read_replicas: readReplicas }, null, 2) }] };
  }

  private async shareProject(args: any) {
    const body: any = {
      email: args.email
    };
    if (args.role) body.role = args.role;

    const response = await this.client.post(`/projects/${args.projectId}/permissions`, body);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async listProjectShares(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/permissions`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async revokeProjectShare(args: any) {
    const response = await this.client.delete(`/projects/${args.projectId}/permissions/${args.shareId}`);
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async listExtensions(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const sql = 'SELECT * FROM pg_available_extensions ORDER BY name';
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: sql });
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async enableExtension(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const schema = args.schema || 'public';
    const sql = `CREATE EXTENSION IF NOT EXISTS "${args.extensionName}" SCHEMA ${schema}`;
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: sql });
    return { content: [{ type: 'text', text: `Extension ${args.extensionName} enabled successfully` }] };
  }

  private async disableExtension(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const sql = `DROP EXTENSION IF EXISTS "${args.extensionName}"`;
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: sql });
    return { content: [{ type: 'text', text: `Extension ${args.extensionName} disabled successfully` }] };
  }

  private async getExtensionDetails(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const sql = `SELECT * FROM pg_extension WHERE extname = '${args.extensionName}'`;
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: sql });
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async updateExtension(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const version = args.version ? `TO '${args.version}'` : '';
    const sql = `ALTER EXTENSION "${args.extensionName}" UPDATE ${version}`;
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: sql });
    return { content: [{ type: 'text', text: `Extension ${args.extensionName} updated successfully` }] };
  }

  private async createMigration(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    // Create migration tracking table if not exists
    const createTableSql = `CREATE TABLE IF NOT EXISTS schema_migrations (
      id SERIAL PRIMARY KEY,
      name VARCHAR(255) NOT NULL,
      sql TEXT NOT NULL,
      applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )`;
    await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: createTableSql });

    // Execute migration
    await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: args.sql });

    // Record migration
    const recordSql = `INSERT INTO schema_migrations (name, sql) VALUES ('${args.name}', '${args.sql.replace(/'/g, "''")}')`;
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: recordSql });
    return { content: [{ type: 'text', text: `Migration ${args.name} created and applied successfully` }] };
  }

  private async listMigrations(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const sql = 'SELECT * FROM schema_migrations ORDER BY applied_at DESC';
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: sql });
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async rollbackMigration(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const sql = `DELETE FROM schema_migrations WHERE id = ${args.migrationId}`;
    const response = await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: sql });
    return { content: [{ type: 'text', text: `Migration ${args.migrationId} rolled back (record deleted, manual SQL rollback required)` }] };
  }

  private async getConnectionUri(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/connection_uri`, {
      params: {
        branch_id: args.branchId,
        database_name: args.databaseName,
        role_name: args.roleName,
        pooled: args.pooled
      }
    });
    const uri = response.data.uri;

    if (args.format) {
      const formatted = this.formatConnectionString(uri, args.format);
      return { content: [{ type: 'text', text: formatted }] };
    }

    return { content: [{ type: 'text', text: uri }] };
  }

  private async testConnection(args: any) {
    const branchId = args.branchId || 'main';
    const dbName = args.databaseName || 'neondb';
    const startTime = Date.now();
    try {
      await this.client.post(`/projects/${args.projectId}/branches/${branchId}/databases/${dbName}/query`, { query: 'SELECT 1' });
      const latency = Date.now() - startTime;
      return { content: [{ type: 'text', text: `Connection successful! Latency: ${latency}ms` }] };
    } catch (error: any) {
      return { content: [{ type: 'text', text: `Connection failed: ${error.message}` }] };
    }
  }

  private async getConnectionExamples(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/connection_uri`, {
      params: {
        branch_id: args.branchId,
        database_name: args.databaseName
      }
    });
    const uri = response.data.uri;

    const examples: any = {
      javascript: `const { Pool } = require('pg');\nconst pool = new Pool({ connectionString: '${uri}' });\n\nconst result = await pool.query('SELECT * FROM users');\nconsole.log(result.rows);`,
      typescript: `import { Pool } from 'pg';\nconst pool = new Pool({ connectionString: '${uri}' });\n\nconst result = await pool.query<User>('SELECT * FROM users');\nconsole.log(result.rows);`,
      python: `import psycopg2\n\nconn = psycopg2.connect('${uri}')\ncur = conn.cursor()\ncur.execute('SELECT * FROM users')\nrows = cur.fetchall()`,
      go: `import (\n  "database/sql"\n  _ "github.com/lib/pq"\n)\n\ndb, err := sql.Open("postgres", "${uri}")\nrows, err := db.Query("SELECT * FROM users")`,
      rust: `use postgres::{Client, NoTls};\n\nlet mut client = Client::connect("${uri}", NoTls)?;\nlet rows = client.query("SELECT * FROM users", &[])?;`,
      java: `import java.sql.*;\n\nString url = "${uri.replace('postgres://', 'jdbc:postgresql://')}";\nConnection conn = DriverManager.getConnection(url);\nStatement stmt = conn.createStatement();\nResultSet rs = stmt.executeQuery("SELECT * FROM users");`,
      php: `<?php\n$conn = pg_connect('${uri}');\n$result = pg_query($conn, 'SELECT * FROM users');\n$rows = pg_fetch_all($result);`,
      ruby: `require 'pg'\n\nconn = PG.connect('${uri}')\nresult = conn.exec('SELECT * FROM users')\nresult.each { |row| puts row }`
    };

    const example = examples[args.language || 'javascript'];
    return { content: [{ type: 'text', text: example }] };
  }

  private async createFromTemplate(args: any) {
    // Note: This is a placeholder - Neon API may not have direct template support
    // This would create a project and then apply template SQL
    const response = await this.client.post('/projects', {
      project: {
        name: args.name,
        region_id: args.region
      }
    });
    return { content: [{ type: 'text', text: `Project created from template: ${JSON.stringify(response.data, null, 2)}` }] };
  }

  private async listTemplates(args: any) {
    // Note: This is a placeholder - returning common templates
    const templates = [
      { id: 'nextjs', name: 'Next.js Starter', description: 'PostgreSQL schema for Next.js apps' },
      { id: 'rails', name: 'Ruby on Rails', description: 'Rails-compatible schema' },
      { id: 'django', name: 'Django', description: 'Django-compatible schema' },
      { id: 'ecommerce', name: 'E-commerce', description: 'Product catalog and orders' },
      { id: 'saas', name: 'SaaS Multi-tenant', description: 'Multi-tenant SaaS schema' }
    ];

    const filtered = args.category
      ? templates.filter(t => t.name.toLowerCase().includes(args.category.toLowerCase()))
      : templates;

    return { content: [{ type: 'text', text: JSON.stringify(filtered, null, 2) }] };
  }

  private async getRealTimeMetrics(args: any) {
    const response = await this.client.get(`/projects/${args.projectId}/operations`, {
      params: { limit: 10 }
    });
    return { content: [{ type: 'text', text: JSON.stringify(response.data, null, 2) }] };
  }

  private async exportMetrics(args: any) {
    const config = {
      destination: args.destination,
      projectId: args.projectId,
      config: args.config,
      message: `Metrics export configured for ${args.destination}. Note: This requires additional setup in your monitoring system.`
    };
    return { content: [{ type: 'text', text: JSON.stringify(config, null, 2) }] };
  }

  private async checkApiKey(args: any) {
    if (!this.isEnabled) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            enabled: false,
            message: 'Neon API key not configured. Set NEON_API_KEY environment variable to enable Neon tools.',
            instructions: 'Get your API key from: https://console.neon.tech/app/settings/api-keys'
          }, null, 2)
        }]
      };
    }

    try {
      // Test API key by listing projects
      await this.client.get('/projects', { params: { limit: 1 } });
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            enabled: true,
            message: 'Neon API key is valid and working!'
          }, null, 2)
        }]
      };
    } catch (error: any) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            enabled: false,
            error: error.message,
            message: 'Neon API key is configured but invalid. Please check your API key.'
          }, null, 2)
        }]
      };
    }
  }

  private async createProjectForRAD(args: any) {
    if (!this.isEnabled) {
      return {
        content: [{
          type: 'text',
          text: 'Error: Neon API key not configured. Set NEON_API_KEY environment variable.'
        }]
      };
    }

    const projectData: any = {
      project: {
        name: args.name || 'RAD Crawler',
        region_id: args.region || 'aws-us-east-1',
        pg_version: 16
      }
    };

    if (args.org_id) {
      projectData.project.org_id = args.org_id;
    }

    const response = await this.client.post('/projects', projectData);
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          success: true,
          project: response.data.project,
          message: 'RAD Crawler project created successfully!',
          next_steps: [
            'Use neon_deploy_schema to deploy your schema',
            'Use neon_get_connection_uri to get connection string'
          ]
        }, null, 2)
      }]
    };
  }

  private async deploySchema(args: any) {
    if (!this.isEnabled) {
      return {
        content: [{
          type: 'text',
          text: 'Error: Neon API key not configured. Set NEON_API_KEY environment variable.'
        }]
      };
    }

    // Split schema into individual statements
    const statements = args.schemaSQL
      .split(';')
      .map((s: string) => s.trim())
      .filter((s: string) => s.length > 0);

    const results = [];
    for (const sql of statements) {
      try {
        const response = await this.client.post(
          `/projects/${args.projectId}/branches/${args.branchId || 'main'}/databases/${args.databaseName || 'neondb'}/query`,
          { query: sql + ';' }
        );
        results.push({ success: true, statement: sql.substring(0, 100) + '...' });
      } catch (error: any) {
        results.push({ success: false, statement: sql.substring(0, 100) + '...', error: error.message });
      }
    }

    const successCount = results.filter(r => r.success).length;
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          success: successCount === results.length,
          total_statements: results.length,
          successful: successCount,
          failed: results.length - successCount,
          results
        }, null, 2)
      }]
    };
  }

  private async verifySchema(args: any) {
    if (!this.isEnabled) {
      return {
        content: [{
          type: 'text',
          text: 'Error: Neon API key not configured. Set NEON_API_KEY environment variable.'
        }]
      };
    }

    const sql = `
      SELECT table_name
      FROM information_schema.tables
      WHERE table_schema = 'public'
      AND table_type = 'BASE TABLE'
    `;

    const response = await this.client.post(
      `/projects/${args.projectId}/branches/${args.branchId || 'main'}/databases/${args.databaseName || 'neondb'}/query`,
      { query: sql }
    );

    const existingTables = response.data.rows.map((r: any) => r.table_name);
    const missingTables = args.requiredTables.filter((t: string) => !existingTables.includes(t));

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          success: missingTables.length === 0,
          existing_tables: existingTables,
          required_tables: args.requiredTables,
          missing_tables: missingTables,
          message: missingTables.length === 0
            ? 'All required tables exist!'
            : `Missing tables: ${missingTables.join(', ')}`
        }, null, 2)
      }]
    };
  }

  private async setupRADDatabase(args: any) {
    if (!this.isEnabled) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: false,
            error: 'Neon API key not configured',
            message: 'Set NEON_API_KEY environment variable to enable autonomous setup.',
            instructions: 'Get your API key from: https://console.neon.tech/app/settings/api-keys'
          }, null, 2)
        }]
      };
    }

    try {
      // Step 1: Create project
      const projectResult = await this.createProjectForRAD({
        name: args.projectName || 'RAD Crawler',
        region: args.region || 'aws-us-east-1',
        org_id: args.org_id
      });
      const project = JSON.parse(projectResult.content[0].text).project;

      // Step 2: Create database
      await this.client.post(
        `/projects/${project.id}/branches/main/databases`,
        { database: { name: args.databaseName || 'rad_production', owner_name: 'neondb_owner' } }
      );

      // Step 3: Deploy schema
      await this.deploySchema({
        projectId: project.id,
        branchId: 'main',
        databaseName: args.databaseName || 'rad_production',
        schemaSQL: args.schemaSQL
      });

      // Step 4: Get connection URI
      const uriResult = await this.getConnectionUri({
        projectId: project.id,
        branchId: 'main',
        databaseName: args.databaseName || 'rad_production',
        pooled: true
      });
      const connectionUri = JSON.parse(uriResult.content[0].text).connection_uri;

      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: true,
            project_id: project.id,
            database_name: args.databaseName || 'rad_production',
            connection_uri: connectionUri,
            message: 'RAD database setup complete! Add NEON_DATABASE_URL to your environment config.',
            next_steps: [
              `Set NEON_DATABASE_URL="${connectionUri}"`,
              'Update WORKING_AUGMENT_CONFIG.json',
              'Restart VS Code'
            ]
          }, null, 2)
        }]
      };
    } catch (error: any) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            success: false,
            error: error.message,
            message: 'Failed to set up RAD database. Check error details above.'
          }, null, 2)
        }]
      };
    }
  }

  private async vercelFetch(endpoint: string, options: RequestInit = {}) {
    const response = await fetch(`${BASE_URL}${endpoint}`, {
      ...options,
      headers: {
        Authorization: `Bearer ${VERCEL_TOKEN}`,
        "Content-Type": "application/json",
        ...options.headers,
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Vercel API error (${response.status}): ${errorText}`);
    }

    return response.json();
  }

  private async listProjects(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v9/projects?${params}`);
    return this.formatResponse(data);
  }

  private async getProject(args: any) {
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    return this.formatResponse(data);
  }

  private async createProject(args: any) {
    const data = await this.vercelFetch(`/v9/projects`, {
      method: "POST",
      body: JSON.stringify(args),
    });
    return this.formatResponse(data);
  }

  private async updateProject(args: any) {
    const { projectId, ...updates } = args;
    const data = await this.vercelFetch(`/v9/projects/${projectId}`, {
      method: "PATCH",
      body: JSON.stringify(updates),
    });
    return this.formatResponse(data);
  }

  private async deleteProject(args: any) {
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async listDeployments(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append("limit", args.limit.toString());
    if (args.state) params.append("state", args.state);
    const data = await this.vercelFetch(
      `/v6/deployments?projectId=${args.projectId}&${params}`
    );
    return this.formatResponse(data);
  }

  private async getDeployment(args: any) {
    const data = await this.vercelFetch(`/v13/deployments/${args.deploymentId}`);
    return this.formatResponse(data);
  }

  private async createDeployment(args: any) {
    const data = await this.vercelFetch(`/v13/deployments`, {
      method: "POST",
      body: JSON.stringify(args),
    });
    return this.formatResponse(data);
  }

  private async cancelDeployment(args: any) {
    const data = await this.vercelFetch(
      `/v12/deployments/${args.deploymentId}/cancel`,
      { method: "PATCH" }
    );
    return this.formatResponse(data);
  }

  private async deleteDeployment(args: any) {
    const data = await this.vercelFetch(`/v13/deployments/${args.deploymentId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async getDeploymentEvents(args: any) {
    const data = await this.vercelFetch(
      `/v3/deployments/${args.deploymentId}/events`
    );
    return this.formatResponse(data);
  }

  private async redeploy(args: any) {
    const data = await this.vercelFetch(
      `/v13/deployments/${args.deploymentId}/redeploy`,
      {
        method: "POST",
        body: JSON.stringify({ target: args.target }),
      }
    );
    return this.formatResponse(data);
  }

  private async listEnvVars(args: any) {
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}/env`);
    return this.formatResponse(data);
  }

  private async createEnvVar(args: any) {
    const { projectId, ...envVar } = args;
    const data = await this.vercelFetch(`/v10/projects/${projectId}/env`, {
      method: "POST",
      body: JSON.stringify(envVar),
    });
    return this.formatResponse(data);
  }

  private async updateEnvVar(args: any) {
    const { projectId, envId, ...updates } = args;
    const data = await this.vercelFetch(`/v9/projects/${projectId}/env/${envId}`, {
      method: "PATCH",
      body: JSON.stringify(updates),
    });
    return this.formatResponse(data);
  }

  private async deleteEnvVar(args: any) {
    const data = await this.vercelFetch(
      `/v9/projects/${args.projectId}/env/${args.envId}`,
      { method: "DELETE" }
    );
    return this.formatResponse(data);
  }

  private async bulkCreateEnvVars(args: any) {
    const { projectId, variables } = args;
    const results = [];
    for (const envVar of variables) {
      try {
        const data = await this.vercelFetch(`/v10/projects/${projectId}/env`, {
          method: "POST",
          body: JSON.stringify(envVar),
        });
        results.push({ success: true, key: envVar.key, data });
      } catch (error: any) {
        results.push({ success: false, key: envVar.key, error: error.message });
      }
    }
    return this.formatResponse({ results });
  }

  private async listDomains(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v5/domains?${params}`);
    return this.formatResponse(data);
  }

  private async getDomain(args: any) {
    const data = await this.vercelFetch(`/v5/domains/${args.domain}`);
    return this.formatResponse(data);
  }

  private async addDomain(args: any) {
    const data = await this.vercelFetch(`/v10/projects/${args.projectId}/domains`, {
      method: "POST",
      body: JSON.stringify({ name: args.domain }),
    });
    return this.formatResponse(data);
  }

  private async removeDomain(args: any) {
    const data = await this.vercelFetch(`/v9/domains/${args.domain}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async verifyDomain(args: any) {
    const data = await this.vercelFetch(`/v6/domains/${args.domain}/verify`, {
      method: "POST",
    });
    return this.formatResponse(data);
  }

  private async listDnsRecords(args: any) {
    const data = await this.vercelFetch(`/v4/domains/${args.domain}/records`);
    return this.formatResponse(data);
  }

  private async createDnsRecord(args: any) {
    const { domain, ...record } = args;
    const data = await this.vercelFetch(`/v2/domains/${domain}/records`, {
      method: "POST",
      body: JSON.stringify(record),
    });
    return this.formatResponse(data);
  }

  private async deleteDnsRecord(args: any) {
    const data = await this.vercelFetch(
      `/v2/domains/${args.domain}/records/${args.recordId}`,
      { method: "DELETE" }
    );
    return this.formatResponse(data);
  }

  private async listTeams(args: any) {
    const data = await this.vercelFetch(`/v2/teams`);
    return this.formatResponse(data);
  }

  private async getTeam(args: any) {
    const data = await this.vercelFetch(`/v2/teams/${args.teamId}`);
    return this.formatResponse(data);
  }

  private async listTeamMembers(args: any) {
    const data = await this.vercelFetch(`/v2/teams/${args.teamId}/members`);
    return this.formatResponse(data);
  }

  private async getDeploymentLogs(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append("limit", args.limit.toString());
    if (args.since) params.append("since", args.since.toString());
    const data = await this.vercelFetch(
      `/v2/deployments/${args.deploymentId}/events?${params}`
    );
    return this.formatResponse(data);
  }

  private async getProjectAnalytics(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(
      `/v1/projects/${args.projectId}/analytics?${params}`
    );
    return this.formatResponse(data);
  }

  private async listEdgeConfigs(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/edge-config?${params}`);
    return this.formatResponse(data);
  }

  private async createEdgeConfig(args: any) {
    const data = await this.vercelFetch(`/v1/edge-config`, {
      method: "POST",
      body: JSON.stringify(args),
    });
    return this.formatResponse(data);
  }

  private async getEdgeConfigItems(args: any) {
    const data = await this.vercelFetch(
      `/v1/edge-config/${args.edgeConfigId}/items`
    );
    return this.formatResponse(data);
  }

  private async updateEdgeConfigItems(args: any) {
    const { edgeConfigId, items } = args;
    const data = await this.vercelFetch(`/v1/edge-config/${edgeConfigId}/items`, {
      method: "PATCH",
      body: JSON.stringify({ items }),
    });
    return this.formatResponse(data);
  }

  private async listWebhooks(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/webhooks`);
    return this.formatResponse(data);
  }

  private async createWebhook(args: any) {
    const { projectId, ...webhook } = args;
    const data = await this.vercelFetch(`/v1/projects/${projectId}/webhooks`, {
      method: "POST",
      body: JSON.stringify(webhook),
    });
    return this.formatResponse(data);
  }

  private async deleteWebhook(args: any) {
    const data = await this.vercelFetch(`/v1/webhooks/${args.webhookId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async listAliases(args: any) {
    const params = new URLSearchParams();
    if (args.projectId) params.append("projectId", args.projectId);
    if (args.limit) params.append("limit", args.limit.toString());
    const query = params.toString() ? `?${params.toString()}` : "";
    const data = await this.vercelFetch(`/v4/aliases${query}`);
    return this.formatResponse(data);
  }

  private async assignAlias(args: any) {
    const data = await this.vercelFetch(`/v2/deployments/${args.deploymentId}/aliases`, {
      method: "POST",
      body: JSON.stringify({ alias: args.alias }),
    });
    return this.formatResponse(data);
  }

  private async deleteAlias(args: any) {
    const data = await this.vercelFetch(`/v2/aliases/${args.aliasId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async listSecrets(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const query = params.toString() ? `?${params.toString()}` : "";
    const data = await this.vercelFetch(`/v3/secrets${query}`);
    return this.formatResponse(data);
  }

  private async createSecret(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const query = params.toString() ? `?${params.toString()}` : "";
    const data = await this.vercelFetch(`/v3/secrets${query}`, {
      method: "POST",
      body: JSON.stringify({ name: args.name, value: args.value }),
    });
    return this.formatResponse(data);
  }

  private async deleteSecret(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const query = params.toString() ? `?${params.toString()}` : "";
    const data = await this.vercelFetch(`/v2/secrets/${args.nameOrId}${query}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async renameSecret(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const query = params.toString() ? `?${params.toString()}` : "";
    const data = await this.vercelFetch(`/v2/secrets/${args.nameOrId}${query}`, {
      method: "PATCH",
      body: JSON.stringify({ name: args.newName }),
    });
    return this.formatResponse(data);
  }

  private async listChecks(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/checks`);
    return this.formatResponse(data);
  }

  private async createCheck(args: any) {
    const { deploymentId, ...check } = args;
    const data = await this.vercelFetch(`/v1/deployments/${deploymentId}/checks`, {
      method: "POST",
      body: JSON.stringify(check),
    });
    return this.formatResponse(data);
  }

  private async updateCheck(args: any) {
    const { deploymentId, checkId, ...update } = args;
    const data = await this.vercelFetch(`/v1/deployments/${deploymentId}/checks/${checkId}`, {
      method: "PATCH",
      body: JSON.stringify(update),
    });
    return this.formatResponse(data);
  }

  private async listDeploymentFiles(args: any) {
    const data = await this.vercelFetch(`/v6/deployments/${args.deploymentId}/files`);
    return this.formatResponse(data);
  }

  private async getDeploymentFile(args: any) {
    const data = await this.vercelFetch(`/v6/deployments/${args.deploymentId}/files/${args.fileId}`);
    return this.formatResponse(data);
  }

  private async blobList(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append("limit", args.limit.toString());
    if (args.cursor) params.append("cursor", args.cursor);
    const data = await this.vercelFetch(`/v1/blob?${params}`);
    return this.formatResponse(data);
  }

  private async blobPut(args: any) {
    const data = await this.vercelFetch(`/v1/blob`, {
      method: "PUT",
      body: JSON.stringify({
        pathname: args.pathname,
        body: args.body,
        contentType: args.contentType,
      }),
    });
    return this.formatResponse(data);
  }

  private async blobDelete(args: any) {
    const data = await this.vercelFetch(`/v1/blob`, {
      method: "DELETE",
      body: JSON.stringify({ url: args.url }),
    });
    return this.formatResponse(data);
  }

  private async blobHead(args: any) {
    const data = await this.vercelFetch(`/v1/blob/head?url=${encodeURIComponent(args.url)}`);
    return this.formatResponse(data);
  }

  private async kvGet(args: any) {
    const data = await this.vercelFetch(`/v1/kv/${args.storeId}/get/${args.key}`);
    return this.formatResponse(data);
  }

  private async kvSet(args: any) {
    const body: any = { key: args.key, value: args.value };
    if (args.ex) body.ex = args.ex;
    const data = await this.vercelFetch(`/v1/kv/${args.storeId}/set`, {
      method: "POST",
      body: JSON.stringify(body),
    });
    return this.formatResponse(data);
  }

  private async kvDelete(args: any) {
    const data = await this.vercelFetch(`/v1/kv/${args.storeId}/delete/${args.key}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async kvListKeys(args: any) {
    const params = new URLSearchParams();
    if (args.pattern) params.append("pattern", args.pattern);
    if (args.cursor) params.append("cursor", args.cursor);
    const data = await this.vercelFetch(`/v1/kv/${args.storeId}/keys?${params}`);
    return this.formatResponse(data);
  }

  private async postgresListDatabases(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/postgres?${params}`);
    return this.formatResponse(data);
  }

  private async postgresCreateDatabase(args: any) {
    const data = await this.vercelFetch(`/v1/postgres`, {
      method: "POST",
      body: JSON.stringify({
        name: args.name,
        region: args.region,
      }),
    });
    return this.formatResponse(data);
  }

  private async postgresDeleteDatabase(args: any) {
    const data = await this.vercelFetch(`/v1/postgres/${args.databaseId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async postgresGetConnectionString(args: any) {
    const data = await this.vercelFetch(`/v1/postgres/${args.databaseId}/connection-string`);
    return this.formatResponse(data);
  }

  private async listFirewallRules(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/rules?${params}`);
    return this.formatResponse(data);
  }

  private async createFirewallRule(args: any) {
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/rules`, {
      method: "POST",
      body: JSON.stringify({
        name: args.name,
        action: args.action,
        condition: args.condition,
      }),
    });
    return this.formatResponse(data);
  }

  private async updateFirewallRule(args: any) {
    const body: any = {};
    if (args.name) body.name = args.name;
    if (args.action) body.action = args.action;
    if (args.enabled !== undefined) body.enabled = args.enabled;
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/rules/${args.ruleId}`, {
      method: "PATCH",
      body: JSON.stringify(body),
    });
    return this.formatResponse(data);
  }

  private async deleteFirewallRule(args: any) {
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/rules/${args.ruleId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async getFirewallAnalytics(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/analytics?${params}`);
    return this.formatResponse(data);
  }

  private async listBlockedIps(args: any) {
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/blocked-ips`);
    return this.formatResponse(data);
  }

  private async blockIp(args: any) {
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/blocked-ips`, {
      method: "POST",
      body: JSON.stringify({
        ipAddress: args.ipAddress,
        notes: args.notes,
      }),
    });
    return this.formatResponse(data);
  }

  private async unblockIp(args: any) {
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/blocked-ips/${encodeURIComponent(args.ipAddress)}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async enableAttackChallengeMode(args: any) {
    const data = await this.vercelFetch(`/v1/security/firewall/${args.projectId}/challenge-mode`, {
      method: "PATCH",
      body: JSON.stringify({ enabled: args.enabled }),
    });
    return this.formatResponse(data);
  }

  private async getSecurityEvents(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    if (args.limit) params.append("limit", args.limit.toString());
    const data = await this.vercelFetch(`/v1/security/events/${args.projectId}?${params}`);
    return this.formatResponse(data);
  }

  private async getRuntimeLogsStream(args: any) {
    const params = new URLSearchParams();
    if (args.follow) params.append("follow", "1");
    if (args.limit) params.append("limit", args.limit.toString());
    const data = await this.vercelFetch(`/v2/deployments/${args.deploymentId}/events?${params}`);
    return this.formatResponse(data);
  }

  private async getBuildLogs(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/builds`);
    return this.formatResponse(data);
  }

  private async getErrorLogs(args: any) {
    const params = new URLSearchParams();
    params.append("type", "error");
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(`/v2/deployments/${args.deploymentId}/events?${params}`);
    return this.formatResponse(data);
  }

  private async getBandwidthUsage(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(`/v1/analytics/${args.projectId}/bandwidth?${params}`);
    return this.formatResponse(data);
  }

  private async getFunctionInvocations(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(`/v1/analytics/${args.projectId}/functions?${params}`);
    return this.formatResponse(data);
  }

  private async getCacheMetrics(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(`/v1/analytics/${args.projectId}/cache?${params}`);
    return this.formatResponse(data);
  }

  private async getTraces(args: any) {
    const params = new URLSearchParams();
    if (args.deploymentId) params.append("deploymentId", args.deploymentId);
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(`/v1/traces/${args.projectId}?${params}`);
    return this.formatResponse(data);
  }

  private async getPerformanceInsights(args: any) {
    const data = await this.vercelFetch(`/v1/insights/${args.projectId}/performance`);
    return this.formatResponse(data);
  }

  private async getWebVitals(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    const data = await this.vercelFetch(`/v1/analytics/${args.projectId}/web-vitals?${params}`);
    return this.formatResponse(data);
  }

  private async getBillingSummary(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/billing/summary?${params}`);
    return this.formatResponse(data);
  }

  private async getUsageMetrics(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/billing/usage?${params}`);
    return this.formatResponse(data);
  }

  private async getInvoice(args: any) {
    const data = await this.vercelFetch(`/v1/billing/invoices/${args.invoiceId}`);
    return this.formatResponse(data);
  }

  private async listInvoices(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    if (args.limit) params.append("limit", args.limit.toString());
    const data = await this.vercelFetch(`/v1/billing/invoices?${params}`);
    return this.formatResponse(data);
  }

  private async getSpendingLimits(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/billing/limits?${params}`);
    return this.formatResponse(data);
  }

  private async updateSpendingLimits(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/billing/limits?${params}`, {
      method: "PATCH",
      body: JSON.stringify({ maxMonthlySpend: args.maxMonthlySpend }),
    });
    return this.formatResponse(data);
  }

  private async getCostBreakdown(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/billing/breakdown?${params}`);
    return this.formatResponse(data);
  }

  private async exportUsageReport(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    params.append("format", args.format);
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/billing/export?${params}`);
    return this.formatResponse(data);
  }

  private async listIntegrations(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/integrations?${params}`);
    return this.formatResponse(data);
  }

  private async getIntegration(args: any) {
    const data = await this.vercelFetch(`/v1/integrations/${args.integrationId}`);
    return this.formatResponse(data);
  }

  private async installIntegration(args: any) {
    const body: any = { integrationSlug: args.integrationSlug };
    if (args.teamId) body.teamId = args.teamId;
    if (args.configuration) body.configuration = args.configuration;
    const data = await this.vercelFetch(`/v1/integrations/install`, {
      method: "POST",
      body: JSON.stringify(body),
    });
    return this.formatResponse(data);
  }

  private async uninstallIntegration(args: any) {
    const data = await this.vercelFetch(`/v1/integrations/${args.integrationId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async listIntegrationConfigurations(args: any) {
    const data = await this.vercelFetch(`/v1/integrations/${args.integrationId}/configurations`);
    return this.formatResponse(data);
  }

  private async updateIntegrationConfiguration(args: any) {
    const data = await this.vercelFetch(`/v1/integrations/${args.integrationId}/configurations/${args.configurationId}`, {
      method: "PATCH",
      body: JSON.stringify(args.configuration),
    });
    return this.formatResponse(data);
  }

  private async getIntegrationLogs(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append("limit", args.limit.toString());
    const data = await this.vercelFetch(`/v1/integrations/${args.integrationId}/logs?${params}`);
    return this.formatResponse(data);
  }

  private async triggerIntegrationSync(args: any) {
    const data = await this.vercelFetch(`/v1/integrations/${args.integrationId}/sync`, {
      method: "POST",
    });
    return this.formatResponse(data);
  }

  private async listAuditLogs(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    if (args.limit) params.append("limit", args.limit.toString());
    const data = await this.vercelFetch(`/v1/audit-logs?${params}`);
    return this.formatResponse(data);
  }

  private async getAuditLog(args: any) {
    const data = await this.vercelFetch(`/v1/audit-logs/${args.logId}`);
    return this.formatResponse(data);
  }

  private async exportAuditLogs(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append("from", args.from.toString());
    if (args.to) params.append("to", args.to.toString());
    params.append("format", args.format);
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/audit-logs/export?${params}`);
    return this.formatResponse(data);
  }

  private async getComplianceReport(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/compliance/${args.reportType}?${params}`);
    return this.formatResponse(data);
  }

  private async listAccessEvents(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    if (args.userId) params.append("userId", args.userId);
    if (args.limit) params.append("limit", args.limit.toString());
    const data = await this.vercelFetch(`/v1/access-events?${params}`);
    return this.formatResponse(data);
  }

  private async listCronJobs(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/crons`);
    return this.formatResponse(data);
  }

  private async createCronJob(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/crons`, {
      method: "POST",
      body: JSON.stringify({
        path: args.path,
        schedule: args.schedule,
      }),
    });
    return this.formatResponse(data);
  }

  private async updateCronJob(args: any) {
    const body: any = {};
    if (args.schedule) body.schedule = args.schedule;
    if (args.enabled !== undefined) body.enabled = args.enabled;
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/crons/${args.cronId}`, {
      method: "PATCH",
      body: JSON.stringify(body),
    });
    return this.formatResponse(data);
  }

  private async deleteCronJob(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/crons/${args.cronId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async triggerCronJob(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/crons/${args.cronId}/trigger`, {
      method: "POST",
    });
    return this.formatResponse(data);
  }

  private async listRedirects(args: any) {
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    // Redirects are part of project configuration
    return this.formatResponse((data as any).redirects || []);
  }

  private async createRedirect(args: any) {
    // Get current project config
    const project = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    const redirects = (project as any).redirects || [];
    redirects.push({
      source: args.source,
      destination: args.destination,
      permanent: args.permanent || false,
    });
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`, {
      method: "PATCH",
      body: JSON.stringify({ redirects }),
    });
    return this.formatResponse(data);
  }

  private async deleteRedirect(args: any) {
    // Get current project config
    const project = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    const redirects = ((project as any).redirects || []).filter((_: any, i: number) => i.toString() !== args.redirectId);
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`, {
      method: "PATCH",
      body: JSON.stringify({ redirects }),
    });
    return this.formatResponse(data);
  }

  private async listCustomHeaders(args: any) {
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    // Headers are part of project configuration
    return this.formatResponse((data as any).headers || []);
  }

  private async createCustomHeader(args: any) {
    // Get current project config
    const project = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    const headers = (project as any).headers || [];
    headers.push({
      source: args.source,
      headers: args.headers,
    });
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`, {
      method: "PATCH",
      body: JSON.stringify({ headers }),
    });
    return this.formatResponse(data);
  }

  private async deleteCustomHeader(args: any) {
    // Get current project config
    const project = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    const headers = ((project as any).headers || []).filter((_: any, i: number) => i.toString() !== args.headerId);
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`, {
      method: "PATCH",
      body: JSON.stringify({ headers }),
    });
    return this.formatResponse(data);
  }

  private async listComments(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/comments`);
    return this.formatResponse(data);
  }

  private async createComment(args: any) {
    const body: any = { text: args.text };
    if (args.path) body.path = args.path;
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/comments`, {
      method: "POST",
      body: JSON.stringify(body),
    });
    return this.formatResponse(data);
  }

  private async updateComment(args: any) {
    const data = await this.vercelFetch(`/v1/comments/${args.commentId}`, {
      method: "PATCH",
      body: JSON.stringify({ text: args.text }),
    });
    return this.formatResponse(data);
  }

  private async deleteComment(args: any) {
    const data = await this.vercelFetch(`/v1/comments/${args.commentId}`, {
      method: "DELETE",
    });
    return this.formatResponse(data);
  }

  private async resolveComment(args: any) {
    const data = await this.vercelFetch(`/v1/comments/${args.commentId}`, {
      method: "PATCH",
      body: JSON.stringify({ resolved: args.resolved }),
    });
    return this.formatResponse(data);
  }

  private async listGitRepositories(args: any) {
    const params = new URLSearchParams();
    if (args.teamId) params.append("teamId", args.teamId);
    const data = await this.vercelFetch(`/v1/git/repositories?${params}`);
    return this.formatResponse(data);
  }

  private async connectGitRepository(args: any) {
    const body: any = {
      type: args.type,
      repo: args.repo,
    };
    if (args.projectId) body.projectId = args.projectId;
    const data = await this.vercelFetch(`/v1/git/repositories`, {
      method: "POST",
      body: JSON.stringify(body),
    });
    return this.formatResponse(data);
  }

  private async disconnectGitRepository(args: any) {
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`, {
      method: "PATCH",
      body: JSON.stringify({ link: null }),
    });
    return this.formatResponse(data);
  }

  private async syncGitRepository(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/git/sync`, {
      method: "POST",
    });
    return this.formatResponse(data);
  }

  private async getGitIntegrationStatus(args: any) {
    const data = await this.vercelFetch(`/v9/projects/${args.projectId}`);
    return this.formatResponse({
      connected: !!(data as any).link,
      link: (data as any).link,
    });
  }

  private async listMiddleware(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/middleware`);
    return this.formatResponse(data);
  }

  private async getMiddlewareLogs(args: any) {
    const params = new URLSearchParams();
    if (args.deploymentId) params.append('deploymentId', args.deploymentId);
    if (args.limit) params.append('limit', args.limit.toString());
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/middleware/logs?${params}`);
    return this.formatResponse(data);
  }

  private async getMiddlewareMetrics(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append('from', args.from);
    if (args.to) params.append('to', args.to);
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/middleware/metrics?${params}`);
    return this.formatResponse(data);
  }

  private async testMiddleware(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/middleware/test`, {
      method: 'POST',
      body: JSON.stringify({ code: args.code, testRequest: args.testRequest })
    });
    return this.formatResponse(data);
  }

  private async deployMiddleware(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/middleware`, {
      method: 'POST',
      body: JSON.stringify({ code: args.code, config: args.config })
    });
    return this.formatResponse(data);
  }

  private async getDeploymentHealth(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/health`);
    return this.formatResponse(data);
  }

  private async getErrorRate(args: any) {
    const params = new URLSearchParams();
    if (args.deploymentId) params.append('deploymentId', args.deploymentId);
    if (args.from) params.append('from', args.from);
    if (args.to) params.append('to', args.to);
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/metrics/errors?${params}`);
    return this.formatResponse(data);
  }

  private async getResponseTime(args: any) {
    const params = new URLSearchParams();
    if (args.deploymentId) params.append('deploymentId', args.deploymentId);
    if (args.from) params.append('from', args.from);
    if (args.to) params.append('to', args.to);
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/metrics/response-time?${params}`);
    return this.formatResponse(data);
  }

  private async getUptimeMetrics(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append('from', args.from);
    if (args.to) params.append('to', args.to);
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/metrics/uptime?${params}`);
    return this.formatResponse(data);
  }

  private async createAlert(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/alerts`, {
      method: 'POST',
      body: JSON.stringify({
        name: args.name,
        metric: args.metric,
        threshold: args.threshold,
        webhookUrl: args.webhookUrl
      })
    });
    return this.formatResponse(data);
  }

  private async inviteTeamMember(args: any) {
    const data = await this.vercelFetch(`/v1/teams/${args.teamId}/members`, {
      method: 'POST',
      body: JSON.stringify({ email: args.email, role: args.role || 'MEMBER' })
    });
    return this.formatResponse(data);
  }

  private async removeTeamMember(args: any) {
    const data = await this.vercelFetch(`/v1/teams/${args.teamId}/members/${args.userId}`, {
      method: 'DELETE'
    });
    return this.formatResponse(data);
  }

  private async updateTeamMemberRole(args: any) {
    const data = await this.vercelFetch(`/v1/teams/${args.teamId}/members/${args.userId}`, {
      method: 'PATCH',
      body: JSON.stringify({ role: args.role })
    });
    return this.formatResponse(data);
  }

  private async getTeamActivity(args: any) {
    const params = new URLSearchParams();
    if (args.limit) params.append('limit', args.limit.toString());
    if (args.from) params.append('from', args.from);
    if (args.to) params.append('to', args.to);
    const data = await this.vercelFetch(`/v1/teams/${args.teamId}/activity?${params}`);
    return this.formatResponse(data);
  }

  private async getTeamUsage(args: any) {
    const params = new URLSearchParams();
    if (args.from) params.append('from', args.from);
    if (args.to) params.append('to', args.to);
    const data = await this.vercelFetch(`/v1/teams/${args.teamId}/usage?${params}`);
    return this.formatResponse(data);
  }

  private async promoteDeployment(args: any) {
    const data = await this.vercelFetch(`/v13/deployments/${args.deploymentId}/promote`, {
      method: 'POST'
    });
    return this.formatResponse(data);
  }

  private async rollbackDeployment(args: any) {
    const data = await this.vercelFetch(`/v13/deployments/${args.projectId}/rollback`, {
      method: 'POST',
      body: JSON.stringify({ targetDeploymentId: args.targetDeploymentId })
    });
    return this.formatResponse(data);
  }

  private async pauseDeployment(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/pause`, {
      method: 'POST'
    });
    return this.formatResponse(data);
  }

  private async resumeDeployment(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/resume`, {
      method: 'POST'
    });
    return this.formatResponse(data);
  }

  private async getDeploymentDiff(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/diff?deployment1=${args.deploymentId1}&deployment2=${args.deploymentId2}`);
    return this.formatResponse(data);
  }

  private async getStorageUsage(args: any) {
    const params = args.teamId ? `?teamId=${args.teamId}` : '';
    const data = await this.vercelFetch(`/v1/storage/usage${params}`);
    return this.formatResponse(data);
  }

  private async optimizeStorage(args: any) {
    const params = args.teamId ? `?teamId=${args.teamId}` : '';
    const data = await this.vercelFetch(`/v1/storage/optimize${params}`);
    return this.formatResponse(data);
  }

  private async exportBlobData(args: any) {
    const data = await this.vercelFetch(`/v1/blob/${args.storeId}/export?format=${args.format || 'json'}`);
    return this.formatResponse(data);
  }

  private async importBlobData(args: any) {
    const data = await this.vercelFetch(`/v1/blob/${args.storeId}/import`, {
      method: 'POST',
      body: JSON.stringify({ data: args.data, format: args.format || 'json' })
    });
    return this.formatResponse(data);
  }

  private async cloneStorage(args: any) {
    const data = await this.vercelFetch(`/v1/storage/clone`, {
      method: 'POST',
      body: JSON.stringify({
        sourceStoreId: args.sourceStoreId,
        targetStoreId: args.targetStoreId
      })
    });
    return this.formatResponse(data);
  }

  private async scanDeploymentSecurity(args: any) {
    const data = await this.vercelFetch(`/v1/deployments/${args.deploymentId}/security-scan`, {
      method: 'POST'
    });
    return this.formatResponse(data);
  }

  private async getSecurityHeaders(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/security-headers`);
    return this.formatResponse(data);
  }

  private async updateSecurityHeaders(args: any) {
    const data = await this.vercelFetch(`/v1/projects/${args.projectId}/security-headers`, {
      method: 'PATCH',
      body: JSON.stringify({ headers: args.headers })
    });
    return this.formatResponse(data);
  }